library asset_image_generator;

import 'dart:io';
import 'dart:convert';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

/// Main class for generating app_images.dart file
class AssetImageGenerator {
  static const List<String> supportedExtensions = [
    '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp', '.svg'
  ];

  /// Generate app_images.dart file from assets in pubspec.yaml
  Future<void> generate({String? outputPath}) async {
    try {
      print('üöÄ Starting asset image generation...');
      
      // Check if pubspec.yaml exists
      final pubspecFile = File('pubspec.yaml');
      if (!pubspecFile.existsSync()) {
        throw Exception('pubspec.yaml not found in current directory');
      }

      // Parse pubspec.yaml to get asset paths
      final pubspecContent = await pubspecFile.readAsString();
      final pubspec = loadYaml(pubspecContent);
      
      final List<String> assetPaths = _extractAssetPaths(pubspec);
      
      if (assetPaths.isEmpty) {
        print('‚ö†Ô∏è  No asset paths found in pubspec.yaml');
        return;
      }

      // Find all image files
      final List<ImageAsset> imageAssets = [];
      for (final assetPath in assetPaths) {
        final assets = await _scanForImages(assetPath);
        imageAssets.addAll(assets);
      }

      if (imageAssets.isEmpty) {
        print('‚ö†Ô∏è  No image assets found');
        return;
      }

      // Generate the app_images.dart file
      final output = outputPath ?? path.join('lib', 'generated', 'app_images.dart');
      await _generateAppImagesFile(imageAssets, output);
      
      print('‚úÖ Generated app_images.dart with ${imageAssets.length} image assets');
      print('üìÅ Location: $output');
      
    } catch (e) {
      print('‚ùå Error: $e');
      rethrow;
    }
  }

  List<String> _extractAssetPaths(dynamic pubspec) {
    final List<String> paths = [];
    
    if (pubspec['flutter'] != null && pubspec['flutter']['assets'] != null) {
      final assets = pubspec['flutter']['assets'];
      if (assets is List) {
        for (final asset in assets) {
          if (asset is String) {
            paths.add(asset);
          }
        }
      }
    }
    
    return paths;
  }

  Future<List<ImageAsset>> _scanForImages(String assetPath) async {
    final List<ImageAsset> images = [];
    final Directory dir = Directory(assetPath.endsWith('/') ? assetPath : path.dirname(assetPath));
    
    if (!dir.existsSync()) {
      print('‚ö†Ô∏è  Directory not found: ${dir.path}');
      return images;
    }

    await for (final entity in dir.list(recursive: true)) {
      if (entity is File) {
        final extension = path.extension(entity.path).toLowerCase();
        if (supportedExtensions.contains(extension)) {
          final relativePath = path.relative(entity.path);
          final variableName = _generateVariableName(entity.path);
          images.add(ImageAsset(
            path: relativePath,
            variableName: variableName,
          ));
        }
      }
    }
    
    return images;
  }

  String _generateVariableName(String filePath) {
    // Get filename without extension
    String fileName = path.basenameWithoutExtension(filePath);
    
    // Replace special characters and spaces with underscores
    fileName = fileName.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
    
    // Remove consecutive underscores
    fileName = fileName.replaceAll(RegExp(r'_+'), '_');
    
    // Remove leading/trailing underscores
    fileName = fileName.replaceAll(RegExp(r'^_+|_+$'), '');
    
    // Ensure it starts with a letter or underscore
    if (fileName.isNotEmpty && RegExp(r'^[0-9]').hasMatch(fileName)) {
      fileName = 'img_$fileName';
    }
    
    // Convert to camelCase
    return _toCamelCase(fileName);
  }

  String _toCamelCase(String input) {
    final parts = input.split('_');
    if (parts.isEmpty) return 'image';
    
    String result = parts.first.toLowerCase();
    for (int i = 1; i < parts.length; i++) {
      if (parts[i].isNotEmpty) {
        result += parts[i][0].toUpperCase() + parts[i].substring(1).toLowerCase();
      }
    }
    
    return result.isEmpty ? 'image' : result;
  }

  Future<void> _generateAppImagesFile(List<ImageAsset> imageAssets, String outputPath) async {
    final buffer = StringBuffer();
    
    // File header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by asset_image_generator');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();
    buffer.writeln('/// AppImages class containing all asset image paths as static constants');
    buffer.writeln('class AppImages {');
    buffer.writeln('  AppImages._();');
    buffer.writeln();
    
    // Sort assets alphabetically by variable name
    imageAssets.sort((a, b) => a.variableName.compareTo(b.variableName));
    
    // Generate static constants
    for (final asset in imageAssets) {
      buffer.writeln('  /// ${asset.path}');
      buffer.writeln('  static const String ${asset.variableName} = \'${asset.path}\';');
      buffer.writeln();
    }
    
    // Generate a list of all assets
    buffer.writeln('  /// List of all image asset paths');
    buffer.writeln('  static const List<String> all = [');
    for (final asset in imageAssets) {
      buffer.writeln('    ${asset.variableName},');
    }
    buffer.writeln('  ];');
    
    buffer.writeln('}');
    
    // Ensure output directory exists
    final outputFile = File(outputPath);
    await outputFile.parent.create(recursive: true);
    
    // Write the file
    await outputFile.writeAsString(buffer.toString());
  }
}

/// Represents an image asset with its path and generated variable name
class ImageAsset {
  final String path;
  final String variableName;
  
  ImageAsset({
    required this.path,
    required this.variableName,
  });
}