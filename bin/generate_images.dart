#!/usr/bin/env dart

import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

void main(List<String> arguments) async {
  final generator = AssetImageGenerator();
  await generator.generate();
}

class AssetImageGenerator {
  static const List<String> supportedExtensions = [
    '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp', '.svg'
  ];

  Future<void> generate() async {
    try {
      print('üöÄ Starting asset image generation...');
      
      // Check if pubspec.yaml exists
      final pubspecFile = File('pubspec.yaml');
      if (!pubspecFile.existsSync()) {
        print('‚ùå Error: pubspec.yaml not found in current directory');
        exit(1);
      }

      // Parse pubspec.yaml to get asset paths
      final pubspecContent = await pubspecFile.readAsString();
      final pubspec = loadYaml(pubspecContent);
      
      final List<String> assetPaths = _extractAssetPaths(pubspec);
      
      if (assetPaths.isEmpty) {
        print('‚ö†Ô∏è  No asset paths found in pubspec.yaml');
        return;
      }

      // Find all image files
      final List<ImageAsset> imageAssets = [];
      for (final assetPath in assetPaths) {
        final assets = await _scanForImages(assetPath);
        imageAssets.addAll(assets);
      }

      if (imageAssets.isEmpty) {
        print('‚ö†Ô∏è  No image assets found');
        return;
      }

      // Generate the app_images.dart file
      await _generateAppImagesFile(imageAssets);
      
      print('‚úÖ Generated app_images.dart with ${imageAssets.length} image assets');
      print('üìÅ Location: lib/generated/app_images.dart');
      
    } catch (e) {
      print('‚ùå Error: $e');
      exit(1);
    }
  }

  List<String> _extractAssetPaths(dynamic pubspec) {
    final List<String> paths = [];
    
    if (pubspec['flutter'] != null && pubspec['flutter']['assets'] != null) {
      final assets = pubspec['flutter']['assets'];
      if (assets is List) {
        for (final asset in assets) {
          if (asset is String) {
            paths.add(asset);
          }
        }
      }
    }
    
    return paths;
  }

  Future<List<ImageAsset>> _scanForImages(String assetPath) async {
    final List<ImageAsset> images = [];
    final Directory dir = Directory(assetPath.endsWith('/') ? assetPath : path.dirname(assetPath));
    
    if (!dir.existsSync()) {
      print('‚ö†Ô∏è  Directory not found: ${dir.path}');
      return images;
    }

    await for (final entity in dir.list(recursive: true)) {
      if (entity is File) {
        final extension = path.extension(entity.path).toLowerCase();
        if (supportedExtensions.contains(extension)) {
          final relativePath = path.relative(entity.path);
          final variableName = _generateVariableName(entity.path);
          images.add(ImageAsset(
            path: relativePath,
            variableName: variableName,
          ));
        }
      }
    }
    
    return images;
  }

  String _generateVariableName(String filePath) {
    // Get filename without extension
    String fileName = path.basenameWithoutExtension(filePath);
    
    // Replace special characters and spaces with underscores
    fileName = fileName.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
    
    // Remove consecutive underscores
    fileName = fileName.replaceAll(RegExp(r'_+'), '_');
    
    // Remove leading/trailing underscores
    fileName = fileName.replaceAll(RegExp(r'^_+|_+$'), '');
    
    // Ensure it starts with a letter or underscore
    if (fileName.isNotEmpty && RegExp(r'^[0-9]').hasMatch(fileName)) {
      fileName = 'img_$fileName';
    }
    
    // Convert to camelCase
    return _toCamelCase(fileName);
  }

  String _toCamelCase(String input) {
    final parts = input.split('_');
    if (parts.isEmpty) return 'image';
    
    String result = parts.first.toLowerCase();
    for (int i = 1; i < parts.length; i++) {
      if (parts[i].isNotEmpty) {
        result += parts[i][0].toUpperCase() + parts[i].substring(1).toLowerCase();
      }
    }
    
    return result.isEmpty ? 'image' : result;
  }

Future<void> _generateAppImagesFile(List<ImageAsset> imageAssets) async {
  final buffer = StringBuffer();
  
  // File header
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// Generated by asset_image_generator');
  buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
  buffer.writeln();
  buffer.writeln('/// AppImages class containing all asset image paths as static constants');
  buffer.writeln('class AppImages {');
  buffer.writeln('  AppImages._();');
  buffer.writeln();
  
  // Sort assets alphabetically by variable name
  imageAssets.sort((a, b) => a.variableName.compareTo(b.variableName));
  
  // Generate static constants
  for (final asset in imageAssets) {
    buffer.writeln('  /// ${asset.path}');
    buffer.writeln('  static const String ${asset.variableName} = \'${asset.path.replaceAll(r'\', '/')}\';');
    buffer.writeln();
  }
  
  // Generate a list of all assets
  buffer.writeln('  /// List of all image asset paths');
  buffer.writeln('  static const List<String> all = [');
  for (final asset in imageAssets) {
    buffer.writeln('    ${asset.variableName},');
  }
  buffer.writeln('  ];');
  
  buffer.writeln('}');
  
  // Ensure lib/generated directory exists
  final generatedDir = Directory(path.join('lib', 'generated'));
  if (!generatedDir.existsSync()) {
    await generatedDir.create(recursive: true);
  }
  
  // Write the file
  final outputFile = File(path.join('lib', 'generated', 'app_images.dart'));
  await outputFile.writeAsString(buffer.toString());
}

}

class ImageAsset {
  final String path;
  final String variableName;
  
  ImageAsset({
    required this.path,
    required this.variableName,
  });}